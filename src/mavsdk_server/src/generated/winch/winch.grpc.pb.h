// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: winch/winch.proto
#ifndef GRPC_winch_2fwinch_2eproto__INCLUDED
#define GRPC_winch_2fwinch_2eproto__INCLUDED

#include "winch/winch.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace mavsdk {
namespace rpc {
namespace winch {

// Enable simple Winch actions.
class WinchService final {
 public:
  static constexpr char const* service_full_name() {
    return "mavsdk.rpc.winch.WinchService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    //
    // Allow motor to freewheel.
    virtual ::grpc::Status WinchRelax(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelaxRequest& request, ::mavsdk::rpc::winch::WinchRelaxResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRelaxResponse>> AsyncWinchRelax(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelaxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRelaxResponse>>(AsyncWinchRelaxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRelaxResponse>> PrepareAsyncWinchRelax(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelaxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRelaxResponse>>(PrepareAsyncWinchRelaxRaw(context, request, cq));
    }
    //
    // Wind or unwind specified length of line, optionally using specified rate.
    virtual ::grpc::Status WinchRelativeLengthControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest& request, ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse>> AsyncWinchRelativeLengthControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse>>(AsyncWinchRelativeLengthControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse>> PrepareAsyncWinchRelativeLengthControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse>>(PrepareAsyncWinchRelativeLengthControlRaw(context, request, cq));
    }
    //
    // Wind or unwind line at specified rate.
    virtual ::grpc::Status WinchRateControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRateControlRequest& request, ::mavsdk::rpc::winch::WinchRateControlResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRateControlResponse>> AsyncWinchRateControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRateControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRateControlResponse>>(AsyncWinchRateControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRateControlResponse>> PrepareAsyncWinchRateControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRateControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRateControlResponse>>(PrepareAsyncWinchRateControlRaw(context, request, cq));
    }
    //
    // Perform the locking sequence to relieve motor while in the fully retracted position. Only action and instance command parameters are used, others are ignored.
    virtual ::grpc::Status WinchLock(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLockRequest& request, ::mavsdk::rpc::winch::WinchLockResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchLockResponse>> AsyncWinchLock(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchLockResponse>>(AsyncWinchLockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchLockResponse>> PrepareAsyncWinchLock(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchLockResponse>>(PrepareAsyncWinchLockRaw(context, request, cq));
    }
    //
    // Sequence of drop, slow down, touch down, reel up, lock. Only action and instance command parameters are used, others are ignored.
    virtual ::grpc::Status WinchDeliver(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchDeliverRequest& request, ::mavsdk::rpc::winch::WinchDeliverResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchDeliverResponse>> AsyncWinchDeliver(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchDeliverRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchDeliverResponse>>(AsyncWinchDeliverRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchDeliverResponse>> PrepareAsyncWinchDeliver(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchDeliverRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchDeliverResponse>>(PrepareAsyncWinchDeliverRaw(context, request, cq));
    }
    //
    // Engage motor and hold current position. Only action and instance command parameters are used, others are ignored.
    virtual ::grpc::Status WinchHold(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchHoldRequest& request, ::mavsdk::rpc::winch::WinchHoldResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchHoldResponse>> AsyncWinchHold(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchHoldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchHoldResponse>>(AsyncWinchHoldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchHoldResponse>> PrepareAsyncWinchHold(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchHoldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchHoldResponse>>(PrepareAsyncWinchHoldRaw(context, request, cq));
    }
    //
    // Return the reel to the fully retracted position. Only action and instance command parameters are used, others are ignored.
    virtual ::grpc::Status WinchRetract(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRetractRequest& request, ::mavsdk::rpc::winch::WinchRetractResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRetractResponse>> AsyncWinchRetract(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRetractRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRetractResponse>>(AsyncWinchRetractRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRetractResponse>> PrepareAsyncWinchRetract(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRetractRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRetractResponse>>(PrepareAsyncWinchRetractRaw(context, request, cq));
    }
    //
    // Load the reel with line. The winch will calculate the total loaded length and stop when the tension exceeds a threshold. Only action and instance command parameters are used, others are ignored.
    virtual ::grpc::Status WinchLoadLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadLineRequest& request, ::mavsdk::rpc::winch::WinchLoadLineResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchLoadLineResponse>> AsyncWinchLoadLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadLineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchLoadLineResponse>>(AsyncWinchLoadLineRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchLoadLineResponse>> PrepareAsyncWinchLoadLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadLineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchLoadLineResponse>>(PrepareAsyncWinchLoadLineRaw(context, request, cq));
    }
    //
    // Spool out the entire length of the line. Only action and instance command parameters are used, others are ignored.
    virtual ::grpc::Status WinchAbandonLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchAbandonLineRequest& request, ::mavsdk::rpc::winch::WinchAbandonLineResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchAbandonLineResponse>> AsyncWinchAbandonLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchAbandonLineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchAbandonLineResponse>>(AsyncWinchAbandonLineRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchAbandonLineResponse>> PrepareAsyncWinchAbandonLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchAbandonLineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchAbandonLineResponse>>(PrepareAsyncWinchAbandonLineRaw(context, request, cq));
    }
    //
    // Spools out just enough to present the hook to the user to load the payload. Only action and instance command parameters are used, others are ignored
    virtual ::grpc::Status WinchLoadPayload(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest& request, ::mavsdk::rpc::winch::WinchLoadPayloadResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchLoadPayloadResponse>> AsyncWinchLoadPayload(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchLoadPayloadResponse>>(AsyncWinchLoadPayloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchLoadPayloadResponse>> PrepareAsyncWinchLoadPayload(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchLoadPayloadResponse>>(PrepareAsyncWinchLoadPayloadRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      //
      // Allow motor to freewheel.
      virtual void WinchRelax(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelaxRequest* request, ::mavsdk::rpc::winch::WinchRelaxResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WinchRelax(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelaxRequest* request, ::mavsdk::rpc::winch::WinchRelaxResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Wind or unwind specified length of line, optionally using specified rate.
      virtual void WinchRelativeLengthControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest* request, ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WinchRelativeLengthControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest* request, ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Wind or unwind line at specified rate.
      virtual void WinchRateControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRateControlRequest* request, ::mavsdk::rpc::winch::WinchRateControlResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WinchRateControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRateControlRequest* request, ::mavsdk::rpc::winch::WinchRateControlResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Perform the locking sequence to relieve motor while in the fully retracted position. Only action and instance command parameters are used, others are ignored.
      virtual void WinchLock(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLockRequest* request, ::mavsdk::rpc::winch::WinchLockResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WinchLock(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLockRequest* request, ::mavsdk::rpc::winch::WinchLockResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Sequence of drop, slow down, touch down, reel up, lock. Only action and instance command parameters are used, others are ignored.
      virtual void WinchDeliver(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchDeliverRequest* request, ::mavsdk::rpc::winch::WinchDeliverResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WinchDeliver(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchDeliverRequest* request, ::mavsdk::rpc::winch::WinchDeliverResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Engage motor and hold current position. Only action and instance command parameters are used, others are ignored.
      virtual void WinchHold(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchHoldRequest* request, ::mavsdk::rpc::winch::WinchHoldResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WinchHold(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchHoldRequest* request, ::mavsdk::rpc::winch::WinchHoldResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Return the reel to the fully retracted position. Only action and instance command parameters are used, others are ignored.
      virtual void WinchRetract(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRetractRequest* request, ::mavsdk::rpc::winch::WinchRetractResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WinchRetract(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRetractRequest* request, ::mavsdk::rpc::winch::WinchRetractResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Load the reel with line. The winch will calculate the total loaded length and stop when the tension exceeds a threshold. Only action and instance command parameters are used, others are ignored.
      virtual void WinchLoadLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadLineRequest* request, ::mavsdk::rpc::winch::WinchLoadLineResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WinchLoadLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadLineRequest* request, ::mavsdk::rpc::winch::WinchLoadLineResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Spool out the entire length of the line. Only action and instance command parameters are used, others are ignored.
      virtual void WinchAbandonLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchAbandonLineRequest* request, ::mavsdk::rpc::winch::WinchAbandonLineResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WinchAbandonLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchAbandonLineRequest* request, ::mavsdk::rpc::winch::WinchAbandonLineResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Spools out just enough to present the hook to the user to load the payload. Only action and instance command parameters are used, others are ignored
      virtual void WinchLoadPayload(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest* request, ::mavsdk::rpc::winch::WinchLoadPayloadResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WinchLoadPayload(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest* request, ::mavsdk::rpc::winch::WinchLoadPayloadResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRelaxResponse>* AsyncWinchRelaxRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelaxRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRelaxResponse>* PrepareAsyncWinchRelaxRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelaxRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse>* AsyncWinchRelativeLengthControlRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse>* PrepareAsyncWinchRelativeLengthControlRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRateControlResponse>* AsyncWinchRateControlRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRateControlRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRateControlResponse>* PrepareAsyncWinchRateControlRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRateControlRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchLockResponse>* AsyncWinchLockRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchLockResponse>* PrepareAsyncWinchLockRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchDeliverResponse>* AsyncWinchDeliverRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchDeliverRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchDeliverResponse>* PrepareAsyncWinchDeliverRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchDeliverRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchHoldResponse>* AsyncWinchHoldRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchHoldRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchHoldResponse>* PrepareAsyncWinchHoldRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchHoldRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRetractResponse>* AsyncWinchRetractRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRetractRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchRetractResponse>* PrepareAsyncWinchRetractRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRetractRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchLoadLineResponse>* AsyncWinchLoadLineRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadLineRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchLoadLineResponse>* PrepareAsyncWinchLoadLineRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadLineRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchAbandonLineResponse>* AsyncWinchAbandonLineRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchAbandonLineRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchAbandonLineResponse>* PrepareAsyncWinchAbandonLineRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchAbandonLineRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchLoadPayloadResponse>* AsyncWinchLoadPayloadRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::WinchLoadPayloadResponse>* PrepareAsyncWinchLoadPayloadRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status WinchRelax(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelaxRequest& request, ::mavsdk::rpc::winch::WinchRelaxResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRelaxResponse>> AsyncWinchRelax(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelaxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRelaxResponse>>(AsyncWinchRelaxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRelaxResponse>> PrepareAsyncWinchRelax(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelaxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRelaxResponse>>(PrepareAsyncWinchRelaxRaw(context, request, cq));
    }
    ::grpc::Status WinchRelativeLengthControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest& request, ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse>> AsyncWinchRelativeLengthControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse>>(AsyncWinchRelativeLengthControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse>> PrepareAsyncWinchRelativeLengthControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse>>(PrepareAsyncWinchRelativeLengthControlRaw(context, request, cq));
    }
    ::grpc::Status WinchRateControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRateControlRequest& request, ::mavsdk::rpc::winch::WinchRateControlResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRateControlResponse>> AsyncWinchRateControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRateControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRateControlResponse>>(AsyncWinchRateControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRateControlResponse>> PrepareAsyncWinchRateControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRateControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRateControlResponse>>(PrepareAsyncWinchRateControlRaw(context, request, cq));
    }
    ::grpc::Status WinchLock(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLockRequest& request, ::mavsdk::rpc::winch::WinchLockResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchLockResponse>> AsyncWinchLock(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchLockResponse>>(AsyncWinchLockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchLockResponse>> PrepareAsyncWinchLock(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchLockResponse>>(PrepareAsyncWinchLockRaw(context, request, cq));
    }
    ::grpc::Status WinchDeliver(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchDeliverRequest& request, ::mavsdk::rpc::winch::WinchDeliverResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchDeliverResponse>> AsyncWinchDeliver(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchDeliverRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchDeliverResponse>>(AsyncWinchDeliverRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchDeliverResponse>> PrepareAsyncWinchDeliver(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchDeliverRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchDeliverResponse>>(PrepareAsyncWinchDeliverRaw(context, request, cq));
    }
    ::grpc::Status WinchHold(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchHoldRequest& request, ::mavsdk::rpc::winch::WinchHoldResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchHoldResponse>> AsyncWinchHold(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchHoldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchHoldResponse>>(AsyncWinchHoldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchHoldResponse>> PrepareAsyncWinchHold(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchHoldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchHoldResponse>>(PrepareAsyncWinchHoldRaw(context, request, cq));
    }
    ::grpc::Status WinchRetract(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRetractRequest& request, ::mavsdk::rpc::winch::WinchRetractResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRetractResponse>> AsyncWinchRetract(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRetractRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRetractResponse>>(AsyncWinchRetractRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRetractResponse>> PrepareAsyncWinchRetract(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRetractRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRetractResponse>>(PrepareAsyncWinchRetractRaw(context, request, cq));
    }
    ::grpc::Status WinchLoadLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadLineRequest& request, ::mavsdk::rpc::winch::WinchLoadLineResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchLoadLineResponse>> AsyncWinchLoadLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadLineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchLoadLineResponse>>(AsyncWinchLoadLineRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchLoadLineResponse>> PrepareAsyncWinchLoadLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadLineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchLoadLineResponse>>(PrepareAsyncWinchLoadLineRaw(context, request, cq));
    }
    ::grpc::Status WinchAbandonLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchAbandonLineRequest& request, ::mavsdk::rpc::winch::WinchAbandonLineResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchAbandonLineResponse>> AsyncWinchAbandonLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchAbandonLineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchAbandonLineResponse>>(AsyncWinchAbandonLineRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchAbandonLineResponse>> PrepareAsyncWinchAbandonLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchAbandonLineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchAbandonLineResponse>>(PrepareAsyncWinchAbandonLineRaw(context, request, cq));
    }
    ::grpc::Status WinchLoadPayload(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest& request, ::mavsdk::rpc::winch::WinchLoadPayloadResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchLoadPayloadResponse>> AsyncWinchLoadPayload(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchLoadPayloadResponse>>(AsyncWinchLoadPayloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchLoadPayloadResponse>> PrepareAsyncWinchLoadPayload(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchLoadPayloadResponse>>(PrepareAsyncWinchLoadPayloadRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void WinchRelax(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelaxRequest* request, ::mavsdk::rpc::winch::WinchRelaxResponse* response, std::function<void(::grpc::Status)>) override;
      void WinchRelax(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelaxRequest* request, ::mavsdk::rpc::winch::WinchRelaxResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void WinchRelativeLengthControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest* request, ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse* response, std::function<void(::grpc::Status)>) override;
      void WinchRelativeLengthControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest* request, ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void WinchRateControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRateControlRequest* request, ::mavsdk::rpc::winch::WinchRateControlResponse* response, std::function<void(::grpc::Status)>) override;
      void WinchRateControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRateControlRequest* request, ::mavsdk::rpc::winch::WinchRateControlResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void WinchLock(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLockRequest* request, ::mavsdk::rpc::winch::WinchLockResponse* response, std::function<void(::grpc::Status)>) override;
      void WinchLock(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLockRequest* request, ::mavsdk::rpc::winch::WinchLockResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void WinchDeliver(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchDeliverRequest* request, ::mavsdk::rpc::winch::WinchDeliverResponse* response, std::function<void(::grpc::Status)>) override;
      void WinchDeliver(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchDeliverRequest* request, ::mavsdk::rpc::winch::WinchDeliverResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void WinchHold(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchHoldRequest* request, ::mavsdk::rpc::winch::WinchHoldResponse* response, std::function<void(::grpc::Status)>) override;
      void WinchHold(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchHoldRequest* request, ::mavsdk::rpc::winch::WinchHoldResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void WinchRetract(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRetractRequest* request, ::mavsdk::rpc::winch::WinchRetractResponse* response, std::function<void(::grpc::Status)>) override;
      void WinchRetract(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRetractRequest* request, ::mavsdk::rpc::winch::WinchRetractResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void WinchLoadLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadLineRequest* request, ::mavsdk::rpc::winch::WinchLoadLineResponse* response, std::function<void(::grpc::Status)>) override;
      void WinchLoadLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadLineRequest* request, ::mavsdk::rpc::winch::WinchLoadLineResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void WinchAbandonLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchAbandonLineRequest* request, ::mavsdk::rpc::winch::WinchAbandonLineResponse* response, std::function<void(::grpc::Status)>) override;
      void WinchAbandonLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchAbandonLineRequest* request, ::mavsdk::rpc::winch::WinchAbandonLineResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void WinchLoadPayload(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest* request, ::mavsdk::rpc::winch::WinchLoadPayloadResponse* response, std::function<void(::grpc::Status)>) override;
      void WinchLoadPayload(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest* request, ::mavsdk::rpc::winch::WinchLoadPayloadResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRelaxResponse>* AsyncWinchRelaxRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelaxRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRelaxResponse>* PrepareAsyncWinchRelaxRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelaxRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse>* AsyncWinchRelativeLengthControlRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse>* PrepareAsyncWinchRelativeLengthControlRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRateControlResponse>* AsyncWinchRateControlRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRateControlRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRateControlResponse>* PrepareAsyncWinchRateControlRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRateControlRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchLockResponse>* AsyncWinchLockRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchLockResponse>* PrepareAsyncWinchLockRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchDeliverResponse>* AsyncWinchDeliverRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchDeliverRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchDeliverResponse>* PrepareAsyncWinchDeliverRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchDeliverRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchHoldResponse>* AsyncWinchHoldRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchHoldRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchHoldResponse>* PrepareAsyncWinchHoldRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchHoldRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRetractResponse>* AsyncWinchRetractRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRetractRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchRetractResponse>* PrepareAsyncWinchRetractRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchRetractRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchLoadLineResponse>* AsyncWinchLoadLineRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadLineRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchLoadLineResponse>* PrepareAsyncWinchLoadLineRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadLineRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchAbandonLineResponse>* AsyncWinchAbandonLineRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchAbandonLineRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchAbandonLineResponse>* PrepareAsyncWinchAbandonLineRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchAbandonLineRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchLoadPayloadResponse>* AsyncWinchLoadPayloadRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::WinchLoadPayloadResponse>* PrepareAsyncWinchLoadPayloadRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_WinchRelax_;
    const ::grpc::internal::RpcMethod rpcmethod_WinchRelativeLengthControl_;
    const ::grpc::internal::RpcMethod rpcmethod_WinchRateControl_;
    const ::grpc::internal::RpcMethod rpcmethod_WinchLock_;
    const ::grpc::internal::RpcMethod rpcmethod_WinchDeliver_;
    const ::grpc::internal::RpcMethod rpcmethod_WinchHold_;
    const ::grpc::internal::RpcMethod rpcmethod_WinchRetract_;
    const ::grpc::internal::RpcMethod rpcmethod_WinchLoadLine_;
    const ::grpc::internal::RpcMethod rpcmethod_WinchAbandonLine_;
    const ::grpc::internal::RpcMethod rpcmethod_WinchLoadPayload_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    //
    // Allow motor to freewheel.
    virtual ::grpc::Status WinchRelax(::grpc::ServerContext* context, const ::mavsdk::rpc::winch::WinchRelaxRequest* request, ::mavsdk::rpc::winch::WinchRelaxResponse* response);
    //
    // Wind or unwind specified length of line, optionally using specified rate.
    virtual ::grpc::Status WinchRelativeLengthControl(::grpc::ServerContext* context, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest* request, ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse* response);
    //
    // Wind or unwind line at specified rate.
    virtual ::grpc::Status WinchRateControl(::grpc::ServerContext* context, const ::mavsdk::rpc::winch::WinchRateControlRequest* request, ::mavsdk::rpc::winch::WinchRateControlResponse* response);
    //
    // Perform the locking sequence to relieve motor while in the fully retracted position. Only action and instance command parameters are used, others are ignored.
    virtual ::grpc::Status WinchLock(::grpc::ServerContext* context, const ::mavsdk::rpc::winch::WinchLockRequest* request, ::mavsdk::rpc::winch::WinchLockResponse* response);
    //
    // Sequence of drop, slow down, touch down, reel up, lock. Only action and instance command parameters are used, others are ignored.
    virtual ::grpc::Status WinchDeliver(::grpc::ServerContext* context, const ::mavsdk::rpc::winch::WinchDeliverRequest* request, ::mavsdk::rpc::winch::WinchDeliverResponse* response);
    //
    // Engage motor and hold current position. Only action and instance command parameters are used, others are ignored.
    virtual ::grpc::Status WinchHold(::grpc::ServerContext* context, const ::mavsdk::rpc::winch::WinchHoldRequest* request, ::mavsdk::rpc::winch::WinchHoldResponse* response);
    //
    // Return the reel to the fully retracted position. Only action and instance command parameters are used, others are ignored.
    virtual ::grpc::Status WinchRetract(::grpc::ServerContext* context, const ::mavsdk::rpc::winch::WinchRetractRequest* request, ::mavsdk::rpc::winch::WinchRetractResponse* response);
    //
    // Load the reel with line. The winch will calculate the total loaded length and stop when the tension exceeds a threshold. Only action and instance command parameters are used, others are ignored.
    virtual ::grpc::Status WinchLoadLine(::grpc::ServerContext* context, const ::mavsdk::rpc::winch::WinchLoadLineRequest* request, ::mavsdk::rpc::winch::WinchLoadLineResponse* response);
    //
    // Spool out the entire length of the line. Only action and instance command parameters are used, others are ignored.
    virtual ::grpc::Status WinchAbandonLine(::grpc::ServerContext* context, const ::mavsdk::rpc::winch::WinchAbandonLineRequest* request, ::mavsdk::rpc::winch::WinchAbandonLineResponse* response);
    //
    // Spools out just enough to present the hook to the user to load the payload. Only action and instance command parameters are used, others are ignored
    virtual ::grpc::Status WinchLoadPayload(::grpc::ServerContext* context, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest* request, ::mavsdk::rpc::winch::WinchLoadPayloadResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_WinchRelax : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WinchRelax() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_WinchRelax() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchRelax(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRelaxRequest* /*request*/, ::mavsdk::rpc::winch::WinchRelaxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWinchRelax(::grpc::ServerContext* context, ::mavsdk::rpc::winch::WinchRelaxRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::winch::WinchRelaxResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WinchRelativeLengthControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WinchRelativeLengthControl() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_WinchRelativeLengthControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchRelativeLengthControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest* /*request*/, ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWinchRelativeLengthControl(::grpc::ServerContext* context, ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WinchRateControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WinchRateControl() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_WinchRateControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchRateControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRateControlRequest* /*request*/, ::mavsdk::rpc::winch::WinchRateControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWinchRateControl(::grpc::ServerContext* context, ::mavsdk::rpc::winch::WinchRateControlRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::winch::WinchRateControlResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WinchLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WinchLock() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_WinchLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchLock(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchLockRequest* /*request*/, ::mavsdk::rpc::winch::WinchLockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWinchLock(::grpc::ServerContext* context, ::mavsdk::rpc::winch::WinchLockRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::winch::WinchLockResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WinchDeliver : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WinchDeliver() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_WinchDeliver() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchDeliver(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchDeliverRequest* /*request*/, ::mavsdk::rpc::winch::WinchDeliverResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWinchDeliver(::grpc::ServerContext* context, ::mavsdk::rpc::winch::WinchDeliverRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::winch::WinchDeliverResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WinchHold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WinchHold() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_WinchHold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchHold(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchHoldRequest* /*request*/, ::mavsdk::rpc::winch::WinchHoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWinchHold(::grpc::ServerContext* context, ::mavsdk::rpc::winch::WinchHoldRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::winch::WinchHoldResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WinchRetract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WinchRetract() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_WinchRetract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchRetract(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRetractRequest* /*request*/, ::mavsdk::rpc::winch::WinchRetractResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWinchRetract(::grpc::ServerContext* context, ::mavsdk::rpc::winch::WinchRetractRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::winch::WinchRetractResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WinchLoadLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WinchLoadLine() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_WinchLoadLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchLoadLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchLoadLineRequest* /*request*/, ::mavsdk::rpc::winch::WinchLoadLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWinchLoadLine(::grpc::ServerContext* context, ::mavsdk::rpc::winch::WinchLoadLineRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::winch::WinchLoadLineResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WinchAbandonLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WinchAbandonLine() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_WinchAbandonLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchAbandonLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchAbandonLineRequest* /*request*/, ::mavsdk::rpc::winch::WinchAbandonLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWinchAbandonLine(::grpc::ServerContext* context, ::mavsdk::rpc::winch::WinchAbandonLineRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::winch::WinchAbandonLineResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WinchLoadPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WinchLoadPayload() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_WinchLoadPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchLoadPayload(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest* /*request*/, ::mavsdk::rpc::winch::WinchLoadPayloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWinchLoadPayload(::grpc::ServerContext* context, ::mavsdk::rpc::winch::WinchLoadPayloadRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::winch::WinchLoadPayloadResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_WinchRelax<WithAsyncMethod_WinchRelativeLengthControl<WithAsyncMethod_WinchRateControl<WithAsyncMethod_WinchLock<WithAsyncMethod_WinchDeliver<WithAsyncMethod_WinchHold<WithAsyncMethod_WinchRetract<WithAsyncMethod_WinchLoadLine<WithAsyncMethod_WinchAbandonLine<WithAsyncMethod_WinchLoadPayload<Service > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_WinchRelax : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_WinchRelax() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::WinchRelaxRequest, ::mavsdk::rpc::winch::WinchRelaxResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::winch::WinchRelaxRequest* request, ::mavsdk::rpc::winch::WinchRelaxResponse* response) { return this->WinchRelax(context, request, response); }));}
    void SetMessageAllocatorFor_WinchRelax(
        ::grpc::MessageAllocator< ::mavsdk::rpc::winch::WinchRelaxRequest, ::mavsdk::rpc::winch::WinchRelaxResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::WinchRelaxRequest, ::mavsdk::rpc::winch::WinchRelaxResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_WinchRelax() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchRelax(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRelaxRequest* /*request*/, ::mavsdk::rpc::winch::WinchRelaxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WinchRelax(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRelaxRequest* /*request*/, ::mavsdk::rpc::winch::WinchRelaxResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_WinchRelativeLengthControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_WinchRelativeLengthControl() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest, ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest* request, ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse* response) { return this->WinchRelativeLengthControl(context, request, response); }));}
    void SetMessageAllocatorFor_WinchRelativeLengthControl(
        ::grpc::MessageAllocator< ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest, ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest, ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_WinchRelativeLengthControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchRelativeLengthControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest* /*request*/, ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WinchRelativeLengthControl(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest* /*request*/, ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_WinchRateControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_WinchRateControl() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::WinchRateControlRequest, ::mavsdk::rpc::winch::WinchRateControlResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::winch::WinchRateControlRequest* request, ::mavsdk::rpc::winch::WinchRateControlResponse* response) { return this->WinchRateControl(context, request, response); }));}
    void SetMessageAllocatorFor_WinchRateControl(
        ::grpc::MessageAllocator< ::mavsdk::rpc::winch::WinchRateControlRequest, ::mavsdk::rpc::winch::WinchRateControlResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::WinchRateControlRequest, ::mavsdk::rpc::winch::WinchRateControlResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_WinchRateControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchRateControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRateControlRequest* /*request*/, ::mavsdk::rpc::winch::WinchRateControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WinchRateControl(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRateControlRequest* /*request*/, ::mavsdk::rpc::winch::WinchRateControlResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_WinchLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_WinchLock() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::WinchLockRequest, ::mavsdk::rpc::winch::WinchLockResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::winch::WinchLockRequest* request, ::mavsdk::rpc::winch::WinchLockResponse* response) { return this->WinchLock(context, request, response); }));}
    void SetMessageAllocatorFor_WinchLock(
        ::grpc::MessageAllocator< ::mavsdk::rpc::winch::WinchLockRequest, ::mavsdk::rpc::winch::WinchLockResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::WinchLockRequest, ::mavsdk::rpc::winch::WinchLockResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_WinchLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchLock(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchLockRequest* /*request*/, ::mavsdk::rpc::winch::WinchLockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WinchLock(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchLockRequest* /*request*/, ::mavsdk::rpc::winch::WinchLockResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_WinchDeliver : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_WinchDeliver() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::WinchDeliverRequest, ::mavsdk::rpc::winch::WinchDeliverResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::winch::WinchDeliverRequest* request, ::mavsdk::rpc::winch::WinchDeliverResponse* response) { return this->WinchDeliver(context, request, response); }));}
    void SetMessageAllocatorFor_WinchDeliver(
        ::grpc::MessageAllocator< ::mavsdk::rpc::winch::WinchDeliverRequest, ::mavsdk::rpc::winch::WinchDeliverResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::WinchDeliverRequest, ::mavsdk::rpc::winch::WinchDeliverResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_WinchDeliver() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchDeliver(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchDeliverRequest* /*request*/, ::mavsdk::rpc::winch::WinchDeliverResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WinchDeliver(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchDeliverRequest* /*request*/, ::mavsdk::rpc::winch::WinchDeliverResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_WinchHold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_WinchHold() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::WinchHoldRequest, ::mavsdk::rpc::winch::WinchHoldResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::winch::WinchHoldRequest* request, ::mavsdk::rpc::winch::WinchHoldResponse* response) { return this->WinchHold(context, request, response); }));}
    void SetMessageAllocatorFor_WinchHold(
        ::grpc::MessageAllocator< ::mavsdk::rpc::winch::WinchHoldRequest, ::mavsdk::rpc::winch::WinchHoldResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::WinchHoldRequest, ::mavsdk::rpc::winch::WinchHoldResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_WinchHold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchHold(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchHoldRequest* /*request*/, ::mavsdk::rpc::winch::WinchHoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WinchHold(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchHoldRequest* /*request*/, ::mavsdk::rpc::winch::WinchHoldResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_WinchRetract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_WinchRetract() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::WinchRetractRequest, ::mavsdk::rpc::winch::WinchRetractResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::winch::WinchRetractRequest* request, ::mavsdk::rpc::winch::WinchRetractResponse* response) { return this->WinchRetract(context, request, response); }));}
    void SetMessageAllocatorFor_WinchRetract(
        ::grpc::MessageAllocator< ::mavsdk::rpc::winch::WinchRetractRequest, ::mavsdk::rpc::winch::WinchRetractResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::WinchRetractRequest, ::mavsdk::rpc::winch::WinchRetractResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_WinchRetract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchRetract(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRetractRequest* /*request*/, ::mavsdk::rpc::winch::WinchRetractResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WinchRetract(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRetractRequest* /*request*/, ::mavsdk::rpc::winch::WinchRetractResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_WinchLoadLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_WinchLoadLine() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::WinchLoadLineRequest, ::mavsdk::rpc::winch::WinchLoadLineResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::winch::WinchLoadLineRequest* request, ::mavsdk::rpc::winch::WinchLoadLineResponse* response) { return this->WinchLoadLine(context, request, response); }));}
    void SetMessageAllocatorFor_WinchLoadLine(
        ::grpc::MessageAllocator< ::mavsdk::rpc::winch::WinchLoadLineRequest, ::mavsdk::rpc::winch::WinchLoadLineResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::WinchLoadLineRequest, ::mavsdk::rpc::winch::WinchLoadLineResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_WinchLoadLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchLoadLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchLoadLineRequest* /*request*/, ::mavsdk::rpc::winch::WinchLoadLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WinchLoadLine(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchLoadLineRequest* /*request*/, ::mavsdk::rpc::winch::WinchLoadLineResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_WinchAbandonLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_WinchAbandonLine() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::WinchAbandonLineRequest, ::mavsdk::rpc::winch::WinchAbandonLineResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::winch::WinchAbandonLineRequest* request, ::mavsdk::rpc::winch::WinchAbandonLineResponse* response) { return this->WinchAbandonLine(context, request, response); }));}
    void SetMessageAllocatorFor_WinchAbandonLine(
        ::grpc::MessageAllocator< ::mavsdk::rpc::winch::WinchAbandonLineRequest, ::mavsdk::rpc::winch::WinchAbandonLineResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::WinchAbandonLineRequest, ::mavsdk::rpc::winch::WinchAbandonLineResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_WinchAbandonLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchAbandonLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchAbandonLineRequest* /*request*/, ::mavsdk::rpc::winch::WinchAbandonLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WinchAbandonLine(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchAbandonLineRequest* /*request*/, ::mavsdk::rpc::winch::WinchAbandonLineResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_WinchLoadPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_WinchLoadPayload() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::WinchLoadPayloadRequest, ::mavsdk::rpc::winch::WinchLoadPayloadResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest* request, ::mavsdk::rpc::winch::WinchLoadPayloadResponse* response) { return this->WinchLoadPayload(context, request, response); }));}
    void SetMessageAllocatorFor_WinchLoadPayload(
        ::grpc::MessageAllocator< ::mavsdk::rpc::winch::WinchLoadPayloadRequest, ::mavsdk::rpc::winch::WinchLoadPayloadResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::WinchLoadPayloadRequest, ::mavsdk::rpc::winch::WinchLoadPayloadResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_WinchLoadPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchLoadPayload(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest* /*request*/, ::mavsdk::rpc::winch::WinchLoadPayloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WinchLoadPayload(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest* /*request*/, ::mavsdk::rpc::winch::WinchLoadPayloadResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_WinchRelax<WithCallbackMethod_WinchRelativeLengthControl<WithCallbackMethod_WinchRateControl<WithCallbackMethod_WinchLock<WithCallbackMethod_WinchDeliver<WithCallbackMethod_WinchHold<WithCallbackMethod_WinchRetract<WithCallbackMethod_WinchLoadLine<WithCallbackMethod_WinchAbandonLine<WithCallbackMethod_WinchLoadPayload<Service > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_WinchRelax : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WinchRelax() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_WinchRelax() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchRelax(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRelaxRequest* /*request*/, ::mavsdk::rpc::winch::WinchRelaxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WinchRelativeLengthControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WinchRelativeLengthControl() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_WinchRelativeLengthControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchRelativeLengthControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest* /*request*/, ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WinchRateControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WinchRateControl() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_WinchRateControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchRateControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRateControlRequest* /*request*/, ::mavsdk::rpc::winch::WinchRateControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WinchLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WinchLock() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_WinchLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchLock(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchLockRequest* /*request*/, ::mavsdk::rpc::winch::WinchLockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WinchDeliver : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WinchDeliver() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_WinchDeliver() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchDeliver(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchDeliverRequest* /*request*/, ::mavsdk::rpc::winch::WinchDeliverResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WinchHold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WinchHold() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_WinchHold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchHold(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchHoldRequest* /*request*/, ::mavsdk::rpc::winch::WinchHoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WinchRetract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WinchRetract() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_WinchRetract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchRetract(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRetractRequest* /*request*/, ::mavsdk::rpc::winch::WinchRetractResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WinchLoadLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WinchLoadLine() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_WinchLoadLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchLoadLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchLoadLineRequest* /*request*/, ::mavsdk::rpc::winch::WinchLoadLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WinchAbandonLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WinchAbandonLine() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_WinchAbandonLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchAbandonLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchAbandonLineRequest* /*request*/, ::mavsdk::rpc::winch::WinchAbandonLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WinchLoadPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WinchLoadPayload() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_WinchLoadPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchLoadPayload(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest* /*request*/, ::mavsdk::rpc::winch::WinchLoadPayloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_WinchRelax : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WinchRelax() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_WinchRelax() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchRelax(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRelaxRequest* /*request*/, ::mavsdk::rpc::winch::WinchRelaxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWinchRelax(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WinchRelativeLengthControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WinchRelativeLengthControl() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_WinchRelativeLengthControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchRelativeLengthControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest* /*request*/, ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWinchRelativeLengthControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WinchRateControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WinchRateControl() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_WinchRateControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchRateControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRateControlRequest* /*request*/, ::mavsdk::rpc::winch::WinchRateControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWinchRateControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WinchLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WinchLock() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_WinchLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchLock(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchLockRequest* /*request*/, ::mavsdk::rpc::winch::WinchLockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWinchLock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WinchDeliver : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WinchDeliver() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_WinchDeliver() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchDeliver(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchDeliverRequest* /*request*/, ::mavsdk::rpc::winch::WinchDeliverResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWinchDeliver(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WinchHold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WinchHold() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_WinchHold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchHold(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchHoldRequest* /*request*/, ::mavsdk::rpc::winch::WinchHoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWinchHold(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WinchRetract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WinchRetract() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_WinchRetract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchRetract(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRetractRequest* /*request*/, ::mavsdk::rpc::winch::WinchRetractResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWinchRetract(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WinchLoadLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WinchLoadLine() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_WinchLoadLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchLoadLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchLoadLineRequest* /*request*/, ::mavsdk::rpc::winch::WinchLoadLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWinchLoadLine(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WinchAbandonLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WinchAbandonLine() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_WinchAbandonLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchAbandonLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchAbandonLineRequest* /*request*/, ::mavsdk::rpc::winch::WinchAbandonLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWinchAbandonLine(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WinchLoadPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WinchLoadPayload() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_WinchLoadPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchLoadPayload(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest* /*request*/, ::mavsdk::rpc::winch::WinchLoadPayloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWinchLoadPayload(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_WinchRelax : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_WinchRelax() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WinchRelax(context, request, response); }));
    }
    ~WithRawCallbackMethod_WinchRelax() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchRelax(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRelaxRequest* /*request*/, ::mavsdk::rpc::winch::WinchRelaxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WinchRelax(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_WinchRelativeLengthControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_WinchRelativeLengthControl() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WinchRelativeLengthControl(context, request, response); }));
    }
    ~WithRawCallbackMethod_WinchRelativeLengthControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchRelativeLengthControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest* /*request*/, ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WinchRelativeLengthControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_WinchRateControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_WinchRateControl() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WinchRateControl(context, request, response); }));
    }
    ~WithRawCallbackMethod_WinchRateControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchRateControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRateControlRequest* /*request*/, ::mavsdk::rpc::winch::WinchRateControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WinchRateControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_WinchLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_WinchLock() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WinchLock(context, request, response); }));
    }
    ~WithRawCallbackMethod_WinchLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchLock(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchLockRequest* /*request*/, ::mavsdk::rpc::winch::WinchLockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WinchLock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_WinchDeliver : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_WinchDeliver() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WinchDeliver(context, request, response); }));
    }
    ~WithRawCallbackMethod_WinchDeliver() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchDeliver(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchDeliverRequest* /*request*/, ::mavsdk::rpc::winch::WinchDeliverResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WinchDeliver(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_WinchHold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_WinchHold() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WinchHold(context, request, response); }));
    }
    ~WithRawCallbackMethod_WinchHold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchHold(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchHoldRequest* /*request*/, ::mavsdk::rpc::winch::WinchHoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WinchHold(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_WinchRetract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_WinchRetract() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WinchRetract(context, request, response); }));
    }
    ~WithRawCallbackMethod_WinchRetract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchRetract(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRetractRequest* /*request*/, ::mavsdk::rpc::winch::WinchRetractResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WinchRetract(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_WinchLoadLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_WinchLoadLine() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WinchLoadLine(context, request, response); }));
    }
    ~WithRawCallbackMethod_WinchLoadLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchLoadLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchLoadLineRequest* /*request*/, ::mavsdk::rpc::winch::WinchLoadLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WinchLoadLine(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_WinchAbandonLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_WinchAbandonLine() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WinchAbandonLine(context, request, response); }));
    }
    ~WithRawCallbackMethod_WinchAbandonLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchAbandonLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchAbandonLineRequest* /*request*/, ::mavsdk::rpc::winch::WinchAbandonLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WinchAbandonLine(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_WinchLoadPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_WinchLoadPayload() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WinchLoadPayload(context, request, response); }));
    }
    ~WithRawCallbackMethod_WinchLoadPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WinchLoadPayload(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest* /*request*/, ::mavsdk::rpc::winch::WinchLoadPayloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WinchLoadPayload(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WinchRelax : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WinchRelax() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::winch::WinchRelaxRequest, ::mavsdk::rpc::winch::WinchRelaxResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::winch::WinchRelaxRequest, ::mavsdk::rpc::winch::WinchRelaxResponse>* streamer) {
                       return this->StreamedWinchRelax(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WinchRelax() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WinchRelax(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRelaxRequest* /*request*/, ::mavsdk::rpc::winch::WinchRelaxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWinchRelax(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::winch::WinchRelaxRequest,::mavsdk::rpc::winch::WinchRelaxResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WinchRelativeLengthControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WinchRelativeLengthControl() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest, ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest, ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse>* streamer) {
                       return this->StreamedWinchRelativeLengthControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WinchRelativeLengthControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WinchRelativeLengthControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest* /*request*/, ::mavsdk::rpc::winch::WinchRelativeLengthControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWinchRelativeLengthControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::winch::WinchRelativeLengthControlRequest,::mavsdk::rpc::winch::WinchRelativeLengthControlResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WinchRateControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WinchRateControl() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::winch::WinchRateControlRequest, ::mavsdk::rpc::winch::WinchRateControlResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::winch::WinchRateControlRequest, ::mavsdk::rpc::winch::WinchRateControlResponse>* streamer) {
                       return this->StreamedWinchRateControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WinchRateControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WinchRateControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRateControlRequest* /*request*/, ::mavsdk::rpc::winch::WinchRateControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWinchRateControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::winch::WinchRateControlRequest,::mavsdk::rpc::winch::WinchRateControlResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WinchLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WinchLock() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::winch::WinchLockRequest, ::mavsdk::rpc::winch::WinchLockResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::winch::WinchLockRequest, ::mavsdk::rpc::winch::WinchLockResponse>* streamer) {
                       return this->StreamedWinchLock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WinchLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WinchLock(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchLockRequest* /*request*/, ::mavsdk::rpc::winch::WinchLockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWinchLock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::winch::WinchLockRequest,::mavsdk::rpc::winch::WinchLockResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WinchDeliver : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WinchDeliver() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::winch::WinchDeliverRequest, ::mavsdk::rpc::winch::WinchDeliverResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::winch::WinchDeliverRequest, ::mavsdk::rpc::winch::WinchDeliverResponse>* streamer) {
                       return this->StreamedWinchDeliver(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WinchDeliver() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WinchDeliver(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchDeliverRequest* /*request*/, ::mavsdk::rpc::winch::WinchDeliverResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWinchDeliver(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::winch::WinchDeliverRequest,::mavsdk::rpc::winch::WinchDeliverResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WinchHold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WinchHold() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::winch::WinchHoldRequest, ::mavsdk::rpc::winch::WinchHoldResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::winch::WinchHoldRequest, ::mavsdk::rpc::winch::WinchHoldResponse>* streamer) {
                       return this->StreamedWinchHold(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WinchHold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WinchHold(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchHoldRequest* /*request*/, ::mavsdk::rpc::winch::WinchHoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWinchHold(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::winch::WinchHoldRequest,::mavsdk::rpc::winch::WinchHoldResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WinchRetract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WinchRetract() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::winch::WinchRetractRequest, ::mavsdk::rpc::winch::WinchRetractResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::winch::WinchRetractRequest, ::mavsdk::rpc::winch::WinchRetractResponse>* streamer) {
                       return this->StreamedWinchRetract(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WinchRetract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WinchRetract(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchRetractRequest* /*request*/, ::mavsdk::rpc::winch::WinchRetractResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWinchRetract(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::winch::WinchRetractRequest,::mavsdk::rpc::winch::WinchRetractResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WinchLoadLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WinchLoadLine() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::winch::WinchLoadLineRequest, ::mavsdk::rpc::winch::WinchLoadLineResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::winch::WinchLoadLineRequest, ::mavsdk::rpc::winch::WinchLoadLineResponse>* streamer) {
                       return this->StreamedWinchLoadLine(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WinchLoadLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WinchLoadLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchLoadLineRequest* /*request*/, ::mavsdk::rpc::winch::WinchLoadLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWinchLoadLine(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::winch::WinchLoadLineRequest,::mavsdk::rpc::winch::WinchLoadLineResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WinchAbandonLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WinchAbandonLine() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::winch::WinchAbandonLineRequest, ::mavsdk::rpc::winch::WinchAbandonLineResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::winch::WinchAbandonLineRequest, ::mavsdk::rpc::winch::WinchAbandonLineResponse>* streamer) {
                       return this->StreamedWinchAbandonLine(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WinchAbandonLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WinchAbandonLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchAbandonLineRequest* /*request*/, ::mavsdk::rpc::winch::WinchAbandonLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWinchAbandonLine(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::winch::WinchAbandonLineRequest,::mavsdk::rpc::winch::WinchAbandonLineResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WinchLoadPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WinchLoadPayload() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::winch::WinchLoadPayloadRequest, ::mavsdk::rpc::winch::WinchLoadPayloadResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::winch::WinchLoadPayloadRequest, ::mavsdk::rpc::winch::WinchLoadPayloadResponse>* streamer) {
                       return this->StreamedWinchLoadPayload(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WinchLoadPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WinchLoadPayload(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::WinchLoadPayloadRequest* /*request*/, ::mavsdk::rpc::winch::WinchLoadPayloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWinchLoadPayload(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::winch::WinchLoadPayloadRequest,::mavsdk::rpc::winch::WinchLoadPayloadResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_WinchRelax<WithStreamedUnaryMethod_WinchRelativeLengthControl<WithStreamedUnaryMethod_WinchRateControl<WithStreamedUnaryMethod_WinchLock<WithStreamedUnaryMethod_WinchDeliver<WithStreamedUnaryMethod_WinchHold<WithStreamedUnaryMethod_WinchRetract<WithStreamedUnaryMethod_WinchLoadLine<WithStreamedUnaryMethod_WinchAbandonLine<WithStreamedUnaryMethod_WinchLoadPayload<Service > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_WinchRelax<WithStreamedUnaryMethod_WinchRelativeLengthControl<WithStreamedUnaryMethod_WinchRateControl<WithStreamedUnaryMethod_WinchLock<WithStreamedUnaryMethod_WinchDeliver<WithStreamedUnaryMethod_WinchHold<WithStreamedUnaryMethod_WinchRetract<WithStreamedUnaryMethod_WinchLoadLine<WithStreamedUnaryMethod_WinchAbandonLine<WithStreamedUnaryMethod_WinchLoadPayload<Service > > > > > > > > > > StreamedService;
};

}  // namespace winch
}  // namespace rpc
}  // namespace mavsdk


#endif  // GRPC_winch_2fwinch_2eproto__INCLUDED
